动态代理和静态代理的区别
静态代理优缺点
动态代理优缺点
cglib和Jdk动态代理的区别

动态代理：JDK动态代理、CGLIB（可以使用jdk动态代理，也可以使用基于asm修改字节码的实现）
静态代理：JDK代理设计模式、Javassist

目前字节码修改框架：ASM、Javassist、AspectJ（编译器级别），cglib就是基于封装的Asm. Spring 就是使用cglib代理库。
AspectJ是插件形式，编译期注入代理代码

1、java代理：动态代理和静态代理
2、java代理技术：JDK、Cglib、javassist、AspectJ、
3、java类加载：ClassLoader、反射
4、java 探针Agent 
5、java字节码修改：javassist、asm
6、java热部署：VirtualMachine、Attach、Agent、Instrumentation


---------------------------------------------------------------------------------------------------------------------
静态代理类：由程序员创建或由特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。
动态代理类：在程序运行时，运用反射机制动态创建而成。

静态代理通常只代理一个类，动态代理是代理一个接口下的多个实现类。
静态代理事先知道要代理的是什么，而动态代理不知道要代理什么东西，只有在运行时才知道。

动态代理是实现JDK里的InvocationHandler接口的invoke方法，但注意的是代理的是接口，也就是你的业务类必须要实现接口，通过Proxy里的newProxyInstance得到代理对象。
还有一种动态代理CGLIB，代理的是类，不需要业务类继承接口，通过派生的子类来实现代理。通过在运行时，动态修改字节码达到修改类的目的。


动态代理：JDK动态代理、CGLIB
静态代理：JDK代理设计模式、Javassist
AspectJ：语言级的AOP实现，编译期用来生成符合java字节码规范的class文件。
ASM和Javassist：字节码操作框架


1、java代理：动态代理和静态代理
2、java代理技术：JDK、Cglib、javassist、AspectJ、
3、java类加载：ClassLoader、反射
4、java 探针Agent 
5、java字节码修改：javassist、asm
6、java热部署：VirtualMachine、Attach、Agent、Instrumentation

http://www.javassist.org
http://jboss-javassist.github.io/javassist/
https://github.com/jboss-javassist/javassist


参考
https://blog.csdn.net/luanlouis/article/details/24589193
https://blog.csdn.net/heyutao007/article/details/49738887
https://www.cnblogs.com/mingziday/p/4889116.html

https://blog.csdn.net/liutengteng130/article/details/46565309


cglib代理
https://blog.csdn.net/heyutao007/article/details/49738887


javassist代理实现
https://blog.csdn.net/mingxin95/article/details/51810499
https://www.jianshu.com/p/dcd7ce106370


AspectJ博客：
https://blog.csdn.net/aitangyong/article/details/50770085


AOP大家都不陌生，它是一种编程理念，一种规范，有很多的实现者如Spring AOP，JBoss AOP，还有我们今天要讲的AspectJ。
我们平时项目用到最多的是Spring AOP，它是用纯Java实现的，不需要专门的编译过程，不需要特殊的类加载器，它在运行期通过JDK动态代理或者Cglib动态代理的方式向目标类织入增强代码。
而AspectJ是语言级的AOP实现，它定义了自己的AOP语法和专门的编译期用来生成符合java字节码规范的class文件。


 代理模式（Proxy Pattern）是对象的结构型模式，代理模式给某一个对象提供了一个代理对象，并由代理对象控制对原对象的引用。
代理模式不会改变原来的接口和行为，只是转由代理干某件事，代理可以控制原来的目标，例如：代理商，代理商只会买东西，但并不会改变行为，不会制造东西。让我们通过下面的代码好好理解一下这句话。

静态代理优缺点
优点：
1、直观感受，静态代理是实实在在的存在的，我们自己写的。
2、在编译期加入，提前就指定好了谁调用谁，效率高。
缺点：
同样，它的优点也成了它致命的缺点。
1、静态代理很麻烦，需要大量的代理类
     当我们有多个目标对象需要代理时，我就需要建立多个代理类，改变原有的代码，改的多了就很有可能出问题，必须要重新测试。
2、重复的代码会出现在各个角落里，违背了一个原则：重复不是好味道
      我们应该杜绝一次次的重复。
3、在编译期加入，系统的灵活性差


动态代理优缺点
优点：
1、一个动态代理类更加简单了，可以解决创建多个静态代理的麻烦，避免不断的重复多余的代码
2、调用目标代码时，会在方法“运行时”动态的加入，决定你是什么类型，才调谁，灵活
缺点：
1、系统灵活了，但是相比而言，效率降低了，比静态代理慢一点
2、动态代理比静态代理在代码的可读性上差了一点，不太容易理解
3、JDK动态代理只能对实现了接口的类进行代理


AOP的拦截功能是由java中的动态代理来实现的。说白了，就是在目标类的基础上增加切面逻辑，生成增强的目标类（该切面逻辑或者在目标类函数执行之前，或者目标类函数执行之后，或者在目标类函数抛出异常时候执行。不同的切入时机对应不同的Interceptor的种类，如BeforeAdviseInterceptor，AfterAdviseInterceptor以及ThrowsAdviseInterceptor等）。

AOP的源码中用到了两种动态代理来实现拦截切入功能：jdk动态代理和cglib动态代理。两种方法同时存在，各有优劣。jdk动态代理是由java内部的反射机制来实现的，cglib动态代理底层则是借助asm来实现的。总的来说，反射机制在生成类的过程中比较高效，而asm在生成类之后的相关执行过程中比较高效（可以通过将asm生成的类进行缓存，这样解决asm生成类过程低效问题）。还有一点必须注意：jdk动态代理的应用前提，必须是目标类基于统一的接口。如果没有上述前提，jdk动态代理不能应用。由此可以看出，jdk动态代理有一定的局限性，cglib这种第三方类库实现的动态代理应用更加广泛，且在效率上更有优势。。


Javassist实现
       一种是使用代理工厂创建，另一种通过使用动态代码创建。使用代理工厂创建时，方法与CGLIB类似，也需要实现一个用于代理逻辑处理的Handler：例如createJavassistDynProxy()；使用动态代码创建，生成字节码，这种方式可以非常灵活，甚至可以在运行时生成业务逻辑，如createJavassistBytecodeDynamicProxy()方法。


cglib和Java代理的区别：
JDK的动态代理依靠接口实现，如果有些类并没有实现接口，则不能使用JDK代理，这就要使用cglib动态代理了。 
Cglib动态代理 
JDK的动态代理机制只能代理实现了接口的类，而没有实现接口的类就不能实现JDK的动态代理，cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。 

一、原理区别：
java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。
而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。
1、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP 
2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP 
3、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换
如何强制使用CGLIB实现AOP？
 （1）添加CGLIB库，SPRING_HOME/cglib/*.jar
 （2）在spring配置文件中加入<aop:aspectj-autoproxy proxy-target-class="true"/>

JDK动态代理和CGLIB(Code Generation Library)字节码生成的区别？
 （1）JDK动态代理只能对实现了接口的类生成代理，而不能针对类
 （2）CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法
   因为是继承，所以该类或方法最好不要声明成final 

---------------------------------------------------------------------------------------------------------------------


---------------------------------------------------------------------------------------------------------------------



---------------------------------------------------------------------------------------------------------------------



---------------------------------------------------------------------------------------------------------------------






---------------------------------------------------------------------------------------------------------------------






---------------------------------------------------------------------------------------------------------------------



---------------------------------------------------------------------------------------------------------------------

