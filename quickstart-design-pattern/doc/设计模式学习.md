设计模式的六大原则
设计模式：23种





---------------------------------------------------------------------------------------------------------------------
设计模式：23种

工厂方法模式：一个抽象工厂，一个抽象产品
抽象工厂模式：一个抽象工厂，多个抽象产品
单例模式：私有构造方法，保证只有一个实例化对象
建造者模式：
原型模式：implements Cloneable，clone出一个产品


适配器模式：一个类型转为另一个类型
装饰者模式：装饰着持有被装饰者对象
代理模式：没有看出来和装饰者有什么区别
外观模式：降低了类类之间的耦合度，有一个中间类持有其他全部类，只需要跟中间类打交道即可
桥接模式：将抽象化与实现化解耦，使得二者可以独立变化，感觉是装饰者的升级，根据方法可以改变被装饰者，可以改变是实现
组合模式：将多个对象组合在一起进行操作，常用于表示树形结构中，例如二叉树，数等
享元模式：实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。如连接池


策略模式：根据参数不同，选择不同的实现
模板方法模式：抽象类定义好流程模板，由子类去做模版中每一个流程的实现

观察者模式：被观察者可以新增、删除观察者，当被观察者有变化时候，轮询通知观察者
迭代子模式：迭代器模式就是顺序访问聚集中的对象，集合中非常常见，包含：一是需要遍历的对象，即聚集对象，二是迭代器对象，用于对聚集对象进行遍历访问。
责任链模式：责任链模式，有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求，所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进行动态的调整。
命令模式：根据不同的命令类，来做出不同的执行

备忘录模式：备份使用，主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象，例如假设有原始类A，A中有各种属性，A可以决定需要备份的属性，备忘录类B是用来存储A的一些内部状态，类C呢，就是一个用来存储备忘录的，且只能存储，不能修改等操作
状态模式：核心思想就是：当对象的状态改变时，同时改变其行为，很好理解！就拿QQ来说，有几种状态，在线、隐身、忙碌等，每个状态对应不同的操作，而且你的好友也能看到你的状态，所以，状态模式就两点：1、可以通过改变状态来获得不同的行为。2、你的好友能同时看到你的变化。

访问者模式：访问者持有不同的对象，执行不同的行为
中介者模式：中介者模式也是用来降低类类之间的耦合的，因为如果类类之间有依赖关系的话，不利于功能的拓展和维护，因为只要修改一个对象，其它关联的对象都得进行修改。
解释器模式：不同的实现类，持有相同的对象，但是行为不同，因为实现类不同

![http连接过程图片](../../quickstart-document/doc/interview/image/design-pattern-relation.png "ReferencePicture")



---------------------------------------------------------------------------------------------------------------------
设计模式
https://www.gitbook.com/book/quanke/design-pattern-java/details


参考文章
http://blog.csdn.net/qq3965470/article/details/52167228
https://www.cnblogs.com/tongkey/p/7170826.html
http://blog.csdn.net/jason0539/article/details/44956775

https://www.cnblogs.com/jasongj/p/5551722.html



http://blog.csdn.net/jason0539/article/details/44956775
创建型模式：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式
结构型模式：适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式
行为型模式：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式
还有两类：并发型模式和线程池模式。

创建型模式：Factory Method、Abstract Factory、Singleton、Builder、Prototype
结构型模式：Adapter、Decorator、Proxy、Facade、Bridge、Composite、Flyweight
行为型模式：Strategy、Template Method、Observer、Iterator、Chain of Responsibility、Command、Memento、State、Visitor、Mediator、Interpreter

Interpreter：java的接口多态

简单工厂模式（Simple Factory）（简单工厂模式不属于23中涉及模式，简单工厂一般分为：普通简单工厂、多方法简单工厂、静态方法简单工厂）
工厂方法模式（Factory Method）
抽象工厂模式（Abstract Factory）

工厂方法模式：一个抽象工厂，一个抽象产品，每个抽象产品派生多个具体产品，每个抽象工厂派生多个具体工厂，每个工厂类只生产一种产品
抽象工厂模式：一个抽象工厂，多个抽象产品，每个抽象产品派生多个具体产品，每个抽象工厂派生多个具体工厂，每个工厂类可以生产多种产品


java中单例模式是一种常见的设计模式，单例模式的写法有好几种，这里主要介绍三种：懒汉式单例、饿汉式单例、登记式单例。
　　单例模式有以下特点：
　　1、单例类只能有一个实例。
　　2、单例类必须自己创建自己的唯一实例。
　　3、单例类必须给所有其他对象提供这一实例。
　　单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。

单例条件：
私有化构造方法


定义：
建造者模式：将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

实用范围
1、当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。
2、当构造过程必须允许被构造的对象有不同表示时。

角色
在这样的设计模式中，有以下几个角色：
1、Builder：为创建一个产品对象的各个部件指定抽象接口。
2、ConcreteBuilder：实现Builder的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示，并提供一个检索产品的接口。
3、Director：构造一个使用Builder接口的对象，指导构建过程。
4、Product：表示被构造的复杂对象。ConcreteBuilder创建该产品的内部表示并定义它的装配过程，包含定义组成部件的类，包括将这些部件装配成最终产品的接口。



使用原型模式创建对象比直接new一个对象在性能上要好的多，因为Object类的clone方法是一个本地方法，它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。
使用原型模式的另一个好处是简化对象的创建，使得创建对象就像我们在编辑文档时的复制粘贴一样简单。
因为以上优点，所以在需要重复地创建相似对象时可以考虑使用原型模式。比如需要在一个循环体内创建对象，假如对象创建过程比较复杂或者循环次数很多的话，使用原型模式不但可以简化创建过程，而且可以使系统的整体性能提高很多。

原型模式的注意事项
1、使用原型模式复制对象不会调用类的构造方法。因为对象的复制是通过调用Object类的clone方法来完成的，它直接在内存中复制数据，因此不会调用到类的构造方法。不但构造方法中的代码不会执行，甚至连访问权限都对原型模式无效。单例模式中，只要将构造方法的访问权限设置为private型，就可以实现单例。但是clone方法直接无视构造方法的权限，所以，单例模式与原型模式是冲突的，在使用时要特别注意。
2、深拷贝与浅拷贝。Object类的clone方法只会拷贝对象中的基本的数据类型（8种基本数据类型byte,char,short,int,long,float,double，boolean），对于数组、容器对象、引用对象等都不会拷贝，这就是浅拷贝。如果要实现深拷贝，必须将原型模式中的数组、容器对象、引用对象等另行拷贝。



责任链模式：
web的filter，项目审批模式（低于1000就1个人审批，大于1000转给下一个人继续审批）


策略模式
如RocketMQ提供的CLI监控接口，Broker服务端的不同的Processor


---------------------------------------------------------------------------------------------------------------------
https://www.jianshu.com/p/807bc228dbc2
https://juejin.im/post/5a52144d6fb9a01c9b65c651


单个类的：单一职责、接口隔离
类接口和子类：里式替换、依赖倒置
迪米特法则、开闭原则


总原则－开闭原则：对扩展开放，对修改封闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。

1、单一职责原则（Single Responsibility Principle，简称SRP ）
核心思想：应该有且仅有一个原因引起类的变更
定义：就一个类而言， 应该仅有一个引起它变化的原因。

2、里氏替换原则（Liskov Substitution Principle,简称LSP）
核心思想：在使用基类的的地方可以任意使用其子类，能保证子类完美替换基类。
定义：所有引用基类的地方必须能透明地使用其子类的对象。

3、依赖倒置原则（Dependence Inversion Principle,简称DIP）
核心思想：高层模块不应该依赖底层模块，二者都该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象；
定义：高层模块不应该依赖于低层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。

4、接口隔离原则（Interface Segregation Principle,简称ISP）
核心思想：类间的依赖关系应该建立在最小的接口上
定义：一个类对另一个类的依赖应该建立在最小的接口上。

5、迪米特法则（Law of Demeter,简称LoD）
核心思想：类间解耦。一个类应该对自己需要耦合或者调用的类知道最少
定义：一个软件实体应当尽可能少地与其他实体发生相互作用。

6、开放封闭原则（Open Close Principle,简称OCP）
核心思想：尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化
定义：类、模块、函数等应该是可以拓展的，但是不可修改。


一句话概括:单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。




设计模式的六大原则：
1、单一职责原则：不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，否则就应该把类拆分。
2、里氏替换原则（Liskov Substitution Principle）：任何基类可以出现的地方，子类一定可以出现。里氏替换原则是继承复用的基石，
3、依赖倒转原则（Dependence Inversion Principle）：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。
4、接口隔离原则（Interface Segregation Principle）：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。
5、迪米特法则（最少知道原则）（Demeter Principle）：一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。
6、开放封闭原则（Open Close Principle,简称OCP）
核心思想：尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化
定义：类、模块、函数等应该是可以拓展的，但是不可修改。


---------------------------------------------------------------------------------------------------------------------







